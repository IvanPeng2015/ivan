## wepy解决的主要问题
1. 修复了一些原生API的缺陷，比如：wx.request的并发问题\等[翻翻wepy库将优化方案引用出来]
2. 对小程序原生API进行promise化处理，async/await, regenerator库的引入
3. []babel自定义配置, 自定义配置新特性.
4. js+json+wxss+wxml => 单文件模式 (自定义组件也是这种简化形式)
5. 加载外部npm包. 在编译过程当中，会递归遍历代码中的require然后将对应依赖文件从node_modules当中拷贝出来，并且修改require为相对路径，从而实现对外部NPM包的支持[手动直接拷贝]>>>>>>>>>>>>目的是js方便复用, 组件模块化方便拆分与复用(考虑到小程序项目数量偏少, 进行拆分的必要性不强烈);
6. []数据绑定方式(优化加强) 脏检查, 表单组件双向绑定的实现.
7. []小程序事件传参的优化[小程序的API更新较快, dataset传string参]
8. []computed计算属性.
9. [x]watcher监听器 ——> rxjs响应式. redux-observable接入
10. [x]redux状态管理

## mpvue 解决的主要问题
1. []webpack构建, 自定义构建策略
2. []开发阶段hot reload
3. []主要集中在vue API的对应上.

**mpvue最佳实践**
1. 精简 data 数据
冗余数据不要挂在 data 里，所有在 data/props/computed 中的数据，每次变更都会从微信小程序的 JSCore 进程，通过 setData 序列化成字符串后发送到 JSRender 进程。所以，如果你的数据量巨大的时候，会导致页面非常卡顿。
2. 优化长列表性能
一般情况下这种页面会有大量的数据，除了遵从上面的建议外还有额外的建议。
* 避免在 v-for 中嵌套子组件，这样可以优化大部分部分 setData 时的冗余数据。
* 通过实践发现 wx:if 和 hidden 的优化肉眼不可见，所以或许可以试试直接通过样式 display 来展示和隐藏。
* 如果列表过长，强烈建议产品思考更好的展示形态。比如只展示热门，多余的折叠等形式。
注：我们对其进行了专门优化，最佳实践时和原生小程序代码的性能相差无几。
3. 合理使用双向绑定 mpvue 建议使用 v-model.lazy 绑定方式以优化性能，此外 v-model 在老基础库下输入框输入时可能存在光标重设的问题。
4. 谨慎选择直接使用小程序的 API 如果你有小程序和H5复用代码的需要，业务代码需要保持对 WEB Vue.js 的兼容性。此时我们不建议在代码中直接调用小程序API，更好的选择是通过桥接适配层屏蔽两端差异。
